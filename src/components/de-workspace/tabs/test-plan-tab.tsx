'use client'

import { useMemo, useState, useEffect, useCallback } from 'react'
import { AlertCircle, CheckCircle2, Clipboard, RefreshCw, Plus } from 'lucide-react'
import { cn } from '@/lib/utils'
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card'
import { Badge } from '@/components/ui/badge'
import { Button } from '@/components/ui/button'
import { TestGroup } from '../test-plan/test-group'
import { TestCaseEditDialog } from '../test-plan/test-case-edit-dialog'
import { GenerateDocButton } from '../shared/generate-doc-button'
import {
  type ExtractedItemWithSession,
  type TestCase,
  type TestCaseType,
  type DEWorkspaceScopeItem,
  generateTestCases,
} from '../types'
import { StructuredTestCaseSection, type StructuredTestCase } from '../entities'

interface TestPlanTabProps {
  designWeekId: string
  extractedItems: ExtractedItemWithSession[]
  scopeItems: DEWorkspaceScopeItem[]
  onRefresh: () => void
  className?: string
  // Structured test cases
  structuredTestCases?: StructuredTestCase[]
  onAddStructuredTestCase?: (testCase: StructuredTestCase) => void
  onUpdateStructuredTestCase?: (testCase: StructuredTestCase) => void
  onDeleteStructuredTestCase?: (id: string) => void
}

export function TestPlanTab({
  designWeekId,
  extractedItems,
  scopeItems,
  onRefresh,
  className,
  structuredTestCases = [],
  onAddStructuredTestCase,
  onUpdateStructuredTestCase,
  onDeleteStructuredTestCase,
}: TestPlanTabProps) {
  // State for manual test cases (persisted in localStorage)
  const [manualTestCases, setManualTestCases] = useState<TestCase[]>([])
  const [editDialogOpen, setEditDialogOpen] = useState(false)
  const [editingTestCase, setEditingTestCase] = useState<TestCase | null>(null)
  const [newTestType, setNewTestType] = useState<TestCaseType>('happy_path')

  // Load manual test cases from localStorage
  useEffect(() => {
    const stored = localStorage.getItem(`test-cases-${designWeekId}`)
    if (stored) {
      try {
        setManualTestCases(JSON.parse(stored))
      } catch {
        // Ignore parse errors
      }
    }
  }, [designWeekId])

  // Save manual test cases to localStorage
  const saveManualTestCases = useCallback(
    (cases: TestCase[]) => {
      localStorage.setItem(`test-cases-${designWeekId}`, JSON.stringify(cases))
    },
    [designWeekId]
  )

  // Generate test cases from extracted items and scope items
  const autoGeneratedTestCases = useMemo(() => {
    return generateTestCases(extractedItems, scopeItems)
  }, [extractedItems, scopeItems])

  // Merge auto-generated and manual test cases
  const testCases = useMemo(() => {
    // Manual test cases with matching IDs override auto-generated ones
    const manualIds = new Set(manualTestCases.map((t) => t.id))
    const filteredAuto = autoGeneratedTestCases.filter((t) => !manualIds.has(t.id))
    return [...filteredAuto, ...manualTestCases]
  }, [autoGeneratedTestCases, manualTestCases])

  // Handle adding a new test case
  const handleAddTest = (type: TestCaseType) => {
    setNewTestType(type)
    setEditingTestCase(null)
    setEditDialogOpen(true)
  }

  // Handle editing an existing test case
  const handleEditTest = (testCase: TestCase) => {
    setEditingTestCase(testCase)
    setNewTestType(testCase.type)
    setEditDialogOpen(true)
  }

  // Handle saving a test case
  const handleSaveTest = (testCase: TestCase) => {
    setManualTestCases((prev) => {
      const existing = prev.findIndex((t) => t.id === testCase.id)
      let next: TestCase[]
      if (existing >= 0) {
        next = [...prev]
        next[existing] = testCase
      } else {
        next = [...prev, testCase]
      }
      saveManualTestCases(next)
      return next
    })
  }

  // Handle deleting a test case
  const handleDeleteTest = (testCaseId: string) => {
    setManualTestCases((prev) => {
      const next = prev.filter((t) => t.id !== testCaseId)
      saveManualTestCases(next)
      return next
    })
  }

  // Group test cases by type
  const groupedTests = useMemo(() => {
    const groups: Record<TestCaseType, TestCase[]> = {
      happy_path: [],
      exception: [],
      guardrail: [],
      scope: [],
      boundary: [],
    }

    for (const testCase of testCases) {
      groups[testCase.type].push(testCase)
    }

    return groups
  }, [testCases])

  // Calculate coverage stats
  const totalTests = testCases.length
  const coveredTests = testCases.filter((t) => t.coverage === 'covered').length
  const gapTests = testCases.filter((t) => t.coverage === 'gap').length
  const coveragePercent = totalTests > 0 ? Math.round((coveredTests / totalTests) * 100) : 0

  // Identify coverage gaps
  const coverageGaps: string[] = []
  if (groupedTests.happy_path.length === 0) {
    coverageGaps.push('No happy path tests - add HAPPY_PATH_STEP items')
  }
  if (groupedTests.exception.length === 0) {
    coverageGaps.push('No exception tests - add EXCEPTION_CASE items')
  }
  if (groupedTests.guardrail.length === 0) {
    coverageGaps.push('No guardrail tests - add GUARDRAIL_NEVER or GUARDRAIL_ALWAYS items')
  }
  if (groupedTests.scope.length === 0 && groupedTests.boundary.length === 0) {
    coverageGaps.push('No scope/boundary tests - add IN_SCOPE or OUT_OF_SCOPE items')
  }

  const hasGoodCoverage = coveragePercent >= 80 && coverageGaps.length === 0

  return (
    <div className={cn('space-y-6', className)}>
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-lg font-semibold text-gray-900">Test Plan</h2>
          <p className="text-sm text-gray-500">
            Auto-generated UAT test cases from scope and process definitions
          </p>
        </div>
        <div className="flex items-center gap-3">
          <Button variant="outline" size="sm" onClick={onRefresh} className="gap-2">
            <RefreshCw className="h-4 w-4" />
            Regenerate
          </Button>
          <GenerateDocButton
            designWeekId={designWeekId}
            documentType="TEST_PLAN"
            disabled={totalTests === 0}
            onGenerate={onRefresh}
          />
        </div>
      </div>

      {/* Coverage Summary */}
      <Card>
        <CardHeader className="pb-3">
          <CardTitle className="text-base flex items-center gap-2">
            <Clipboard className="h-4 w-4 text-indigo-500" />
            Test Coverage Summary
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
            <div className="text-center p-3 bg-gray-50 rounded-lg">
              <p className="text-2xl font-bold text-gray-900">{totalTests}</p>
              <p className="text-sm text-gray-500">Total Tests</p>
            </div>
            <div className="text-center p-3 bg-emerald-50 rounded-lg">
              <p className="text-2xl font-bold text-emerald-600">{coveredTests}</p>
              <p className="text-sm text-emerald-700">Covered</p>
            </div>
            <div className="text-center p-3 bg-red-50 rounded-lg">
              <p className="text-2xl font-bold text-red-600">{gapTests}</p>
              <p className="text-sm text-red-700">Gaps</p>
            </div>
            <div className="text-center p-3 bg-indigo-50 rounded-lg">
              <p className="text-2xl font-bold text-indigo-600">{coveragePercent}%</p>
              <p className="text-sm text-indigo-700">Coverage</p>
            </div>
          </div>

          {/* Coverage status message */}
          {hasGoodCoverage ? (
            <div className="mt-4 flex items-center gap-2 p-3 bg-emerald-50 border border-emerald-200 rounded-lg">
              <CheckCircle2 className="h-5 w-5 text-emerald-600" />
              <p className="text-sm text-emerald-700 font-medium">
                Good test coverage! Ready for UAT.
              </p>
            </div>
          ) : (
            coverageGaps.length > 0 && (
              <div className="mt-4 p-3 bg-amber-50 border border-amber-200 rounded-lg">
                <div className="flex items-start gap-2">
                  <AlertCircle className="h-5 w-5 text-amber-600 mt-0.5 flex-shrink-0" />
                  <div>
                    <p className="text-sm text-amber-800 font-medium">Coverage Gaps Detected</p>
                    <ul className="mt-1 text-sm text-amber-700 list-disc list-inside">
                      {coverageGaps.map((gap, index) => (
                        <li key={index}>{gap}</li>
                      ))}
                    </ul>
                  </div>
                </div>
              </div>
            )
          )}
        </CardContent>
      </Card>

      {/* Structured Test Cases (Manual Entry) */}
      {onAddStructuredTestCase && onUpdateStructuredTestCase && (
        <StructuredTestCaseSection
          testCases={structuredTestCases}
          onAdd={onAddStructuredTestCase}
          onUpdate={onUpdateStructuredTestCase}
          onDelete={onDeleteStructuredTestCase}
        />
      )}

      {/* Test Type Breakdown */}
      <div className="grid grid-cols-5 gap-3">
        {(Object.entries(groupedTests) as [TestCaseType, TestCase[]][]).map(([type, tests]) => (
          <Card key={type} className="text-center">
            <CardContent className="pt-4 pb-3">
              <p className="text-xl font-bold text-gray-900">{tests.length}</p>
              <p className="text-xs text-gray-500 capitalize">{type.replace('_', ' ')}</p>
            </CardContent>
          </Card>
        ))}
      </div>

      {/* Test Groups */}
      <div className="space-y-4">
        <TestGroup
          type="happy_path"
          testCases={groupedTests.happy_path}
          defaultExpanded
          onAddTest={() => handleAddTest('happy_path')}
          onEditTest={handleEditTest}
        />
        <TestGroup
          type="exception"
          testCases={groupedTests.exception}
          defaultExpanded={groupedTests.exception.length > 0}
          onAddTest={() => handleAddTest('exception')}
          onEditTest={handleEditTest}
        />
        <TestGroup
          type="guardrail"
          testCases={groupedTests.guardrail}
          defaultExpanded={groupedTests.guardrail.length > 0}
          onAddTest={() => handleAddTest('guardrail')}
          onEditTest={handleEditTest}
        />
        <TestGroup
          type="scope"
          testCases={groupedTests.scope}
          defaultExpanded={false}
          onAddTest={() => handleAddTest('scope')}
          onEditTest={handleEditTest}
        />
        <TestGroup
          type="boundary"
          testCases={groupedTests.boundary}
          defaultExpanded={false}
          onAddTest={() => handleAddTest('boundary')}
          onEditTest={handleEditTest}
        />
      </div>

      {/* Empty state */}
      {totalTests === 0 && (
        <Card className="border-dashed">
          <CardContent className="py-12 text-center">
            <Clipboard className="h-12 w-12 mx-auto text-gray-300 mb-4" />
            <h3 className="text-lg font-medium text-gray-900 mb-2">No test cases yet</h3>
            <p className="text-sm text-gray-500 mb-4 max-w-md mx-auto">
              Test cases are automatically generated from happy path steps, exception cases,
              guardrails, and scope items. Complete the Business and Technical profiles to generate
              test coverage.
            </p>
            <div className="flex items-center justify-center gap-3">
              <Button variant="outline" onClick={onRefresh}>
                Check for Updates
              </Button>
              <Button onClick={() => handleAddTest('happy_path')}>
                <Plus className="w-4 h-4 mr-2" />
                Add Test Manually
              </Button>
            </div>
          </CardContent>
        </Card>
      )}

      {/* Test Case Edit Dialog */}
      <TestCaseEditDialog
        open={editDialogOpen}
        onOpenChange={setEditDialogOpen}
        testCase={editingTestCase}
        defaultType={newTestType}
        onSave={handleSaveTest}
        onDelete={editingTestCase?.sourceType === 'manual' ? handleDeleteTest : undefined}
      />
    </div>
  )
}
